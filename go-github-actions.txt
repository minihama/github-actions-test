다음은 Go 웹 애플리케이션, Nginx 리버스 프록시, Docker 및 GitHub Actions를 사용하여 CI/CD 파이프라인을 구축하는 전체 구성입니다.

## 1. 파일 구조

- `github-actions-test/`
  - `.github/workflows/ci.yml`
  - `go/hello-world/`
    - `main.go`
    - `main_test.go`
    - `go.mod`
    - `Dockerfile`
  - `docker-compose.yml`
  - `nginx.conf`
  - `VERSION`

## 2. 버전 파일 (`VERSION`)

```
v0.1.0
```

## 3. Go 웹 애플리케이션 (`go/hello-world/main.go`)

```go
package main

import (
	"fmt"
	"net/http"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello, World!")
}

func main() {
	http.HandleFunc("/", helloHandler)
	fmt.Println("Server starting on port 8080...")
	if err := http.ListenAndServe(":8080", nil); err != nil {
		fmt.Printf("Error starting server: %s\n", err)
	}
}
```

## 4. Go 테스트 코드 (`go/hello-world/main_test.go`)

```go
package main

import (
	"net/http"
	"net/http/httptest"
	"testing"
)

func Test_helloHandler(t *testing.T) {
	req, err := http.NewRequest("GET", "/", nil)
	if err != nil {
		t.Fatal(err)
	}

	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(helloHandler)

	handler.ServeHTTP(rr, req)

	if status := rr.Code; status != http.StatusOK {
		t.Errorf("handler returned wrong status code: got %v want %v",
			status, http.StatusOK)
	}

	expected := `Hello, World!`
	if rr.Body.String() != expected {
		t.Errorf("handler returned unexpected body: got %v want %v",
			rr.Body.String(), expected)
	}
}
```

## 5. Go 모듈 파일 (`go/hello-world/go.mod`)

```
module github.com/minih/github-actions-test

go 1.24.5
```

## 6. Dockerfile (`go/hello-world/Dockerfile`)

```dockerfile
# Build stage
FROM golang:1.24-alpine AS builder

WORKDIR /app

# Copy go.mod
COPY go.mod ./

# Download dependencies
RUN go mod download

# Copy the entire source code
COPY . .

# Build the Go app
RUN CGO_ENABLED=0 GOOS=linux go build -o /go-app .

# Final stage
FROM alpine:latest

WORKDIR /root/

# Copy the pre-built binary from the builder stage
COPY --from=builder /go-app .

EXPOSE 8080

# Command to run the executable
CMD ["./go-app"]
```

## 7. Docker Compose 파일 (`docker-compose.yml`)

```yaml
services:
  app:
    build: ./go/hello-world
    container_name: go-app

  nginx:
    image: nginx:latest
    container_name: nginx-proxy
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app
```

## 8. Nginx 설정 파일 (`nginx.conf`)

```nginx
events {}

http {
    server {
        listen 80;

        location / {
            proxy_pass http://app:8080;
        }
    }
}
```

## 9. GitHub Actions 워크플로우 (`.github/workflows/ci.yml`)

```yaml
name: Go CI and Versioning

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-and-version:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        # `git push`를 사용하기 위해 PAT(Personal Access Token)가 필요합니다.
        # GitHub 저장소의 Secrets에 `GH_PAT`라는 이름으로 토큰을 저장해야 합니다.
        token: ${{ secrets.GH_PAT }}

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Run tests
      run: go test -v ./go/hello-world/*.go

    - name: Build with Docker Compose
      run: docker compose build

    - name: Bump version and push
      # main 브랜치에 push 이벤트가 발생했을 때만 실행합니다.
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        git config --global user.name 'github-actions[bot]'
        git config --global user.email 'github-actions[bot]@users.noreply.github.com'
        
        # 현재 버전 읽기
        current_version=$(cat VERSION)
        
        # 버전 업데이트 (vX.Y.Z -> vX.Y.Z+1)
        new_version=$(echo $current_version | awk -F. '{OFS="."; $3++; print}')
        
        # VERSION 파일 업데이트
        echo $new_version > VERSION
        
        # 변경사항 커밋 및 푸시
        git add VERSION
        git commit -m "Bump version to $new_version"
        git push
```